{
    "docs": [
        {
            "location": "/",
            "text": "Node Example\n\n\nROS\n allows for creating nodes that communicate with each other.\nIt is very common to use C++ and Python to write these nodes.\n\n\nThis package contains example nodes written in C++ and Python that show minimal examples of using\nsome very basic but powerful features of ROS.\nThose features include:\n\n\n\n\nparameter server\n\n\ndynamic reconfigure\n\n\ntimers\n\n\ncustom messages\n\n\nclasses with callback functions for\n    \npublishers and subscribers\n\n\nremap\n topic names\n\n\n\n\nMore ideas that are explored are deploying documentation using \nGitHub Pages\n,\nwriting unit tests, and checking build status and code coverage.\n\n\nDescription\n\n\nThere are several launch files included, the main one being \nnode_example.launch\n.\nThis will start a talker and listener written in C++ and a talker and listener written in Python.\nOne GUI will open allowing you to see what messages are being recieved by the listeners and another GUI will allow\nyou to change the values sent from each talker.\nBoth listener nodes receive messages from both talkers, showing that the languages used to write the talkers and\nlisteners can be mixed.\n\n\nUsage\n\n\nBuild a workspace\n containing this repository.\nA \nnode_example.rosinstall\n file has been included for convenience with \nwstool\n.\n\n\nTo start all the nodes run\n\n\nroslaunch node_example node_example.launch\n\n\n\nYou should see two windows open: \nrqt_reconfigure\n and \nrqt_console\n.\nThey will look like the following screenshots.\n\n\n\n\n\n\nAt this point you can modify the strings or numbers in the reconfigure GUI and you should see those changes show\nup in the console GUI.\nThere are \nenable\n parameters in each of the talker nodes so that the nodes can effectively be paused during runtime.\nThis is a nice feature that allows easily turning system components on and off during operation for whatever reason\n(such as wanting to run multiple similar nodes side-by-side for comparison without using too many CPU/RAM resources,\nonly running certain nodes when some conditions are met, etc.).\n\n\nBranches\n\n\nThe \nmaster\n branch will try to keep up with the latest long-term support release version of ROS (currently Kinetic).\nThe \nhydro-dev\n branch was tested on ROS Hydro, Indigo, and Kinetic.\nThe \nfuerte-dev\n branch was tested on ROS Fuerte.\n\n\nTesting\n\n\nDuring development there are large benefits to employing unit tests to verify that code changes do not break existing functionality.\nThis package contains unit tests for each of the C++ nodes.\nThe unit tests are run using the \n*.test\n files in the \ntest/\n directory.\nThe \n*.test\n files start the node to be tested plus the unit test code.\nThe unit test code is written such that it publishes and subscribes to the topics that correspond to the interfaces of the node under test.\nCallbacks are used to verify that the expected data is available on the specified topics.\n\n\nThere are several methods of running the unit tests.\nRunning the tests with continuous integration services for pull requests is a common method used to ensure pull requests can be safely merged.\nA popular continuous integration provider for open source projects is \nTravis CI\n.\nThe build and test results for this package can be found in the table at the top of this page.\n\n\nUnit tests are not magic bullets.\nThe inputs to the nodes must take on enough values to verify that functions return valid values.\nThis will be different for each function and is not fully covered here.\nAnother aspect of unit tests is to ensure that all lines of code are exercised by unit tests, also referred to as code coverage.\n\n\nA popular code coverage provider for open source projects is \ncodecov\n.\nThe code coverage results for this package can be found in the table at the top of this page.\nThis tool provides some measure of confidence that the existing unit tests will catch any issues, and that new changes are introduced with unit test code.\n\n\nThe configuration file for Travis is in this repository at \n.travis.yml\n.\nThat file contains build flags to ensure that unit tests run and that code coverage results can be calculated.",
            "title": "Home"
        },
        {
            "location": "/#node-example",
            "text": "ROS  allows for creating nodes that communicate with each other.\nIt is very common to use C++ and Python to write these nodes.  This package contains example nodes written in C++ and Python that show minimal examples of using\nsome very basic but powerful features of ROS.\nThose features include:   parameter server  dynamic reconfigure  timers  custom messages  classes with callback functions for\n     publishers and subscribers  remap  topic names   More ideas that are explored are deploying documentation using  GitHub Pages ,\nwriting unit tests, and checking build status and code coverage.",
            "title": "Node Example"
        },
        {
            "location": "/#description",
            "text": "There are several launch files included, the main one being  node_example.launch .\nThis will start a talker and listener written in C++ and a talker and listener written in Python.\nOne GUI will open allowing you to see what messages are being recieved by the listeners and another GUI will allow\nyou to change the values sent from each talker.\nBoth listener nodes receive messages from both talkers, showing that the languages used to write the talkers and\nlisteners can be mixed.",
            "title": "Description"
        },
        {
            "location": "/#usage",
            "text": "Build a workspace  containing this repository.\nA  node_example.rosinstall  file has been included for convenience with  wstool .  To start all the nodes run  roslaunch node_example node_example.launch  You should see two windows open:  rqt_reconfigure  and  rqt_console .\nThey will look like the following screenshots.    At this point you can modify the strings or numbers in the reconfigure GUI and you should see those changes show\nup in the console GUI.\nThere are  enable  parameters in each of the talker nodes so that the nodes can effectively be paused during runtime.\nThis is a nice feature that allows easily turning system components on and off during operation for whatever reason\n(such as wanting to run multiple similar nodes side-by-side for comparison without using too many CPU/RAM resources,\nonly running certain nodes when some conditions are met, etc.).",
            "title": "Usage"
        },
        {
            "location": "/#branches",
            "text": "The  master  branch will try to keep up with the latest long-term support release version of ROS (currently Kinetic).\nThe  hydro-dev  branch was tested on ROS Hydro, Indigo, and Kinetic.\nThe  fuerte-dev  branch was tested on ROS Fuerte.",
            "title": "Branches"
        },
        {
            "location": "/#testing",
            "text": "During development there are large benefits to employing unit tests to verify that code changes do not break existing functionality.\nThis package contains unit tests for each of the C++ nodes.\nThe unit tests are run using the  *.test  files in the  test/  directory.\nThe  *.test  files start the node to be tested plus the unit test code.\nThe unit test code is written such that it publishes and subscribes to the topics that correspond to the interfaces of the node under test.\nCallbacks are used to verify that the expected data is available on the specified topics.  There are several methods of running the unit tests.\nRunning the tests with continuous integration services for pull requests is a common method used to ensure pull requests can be safely merged.\nA popular continuous integration provider for open source projects is  Travis CI .\nThe build and test results for this package can be found in the table at the top of this page.  Unit tests are not magic bullets.\nThe inputs to the nodes must take on enough values to verify that functions return valid values.\nThis will be different for each function and is not fully covered here.\nAnother aspect of unit tests is to ensure that all lines of code are exercised by unit tests, also referred to as code coverage.  A popular code coverage provider for open source projects is  codecov .\nThe code coverage results for this package can be found in the table at the top of this page.\nThis tool provides some measure of confidence that the existing unit tests will catch any issues, and that new changes are introduced with unit test code.  The configuration file for Travis is in this repository at  .travis.yml .\nThat file contains build flags to ensure that unit tests run and that code coverage results can be calculated.",
            "title": "Testing"
        }
    ]
}